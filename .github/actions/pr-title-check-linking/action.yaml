name: "PR Title Linker & Labeler"
description: "Enforces PR title conventions, links issues, and applies labels."
inputs:
  github-token:
    description: "GitHub Token for API access"
    required: true

runs:
  using: "composite"
  steps:
    - name: Run PR Metadata Script
      uses: actions/github-script@v8
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const { title, body, number } = context.payload.pull_request;
          const header = "**Watch out! Invalid PR Title Format:**";

          // Helper Functions
          async function getAllComments() {
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: number,
            });
            return comments;
          }

          async function deleteCommentIfExists(commentId) {
            if (commentId) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId
              });
            }
          }

          async function createOrUpdateComment(existingComment, messageBody) {
            if (existingComment) {
              if (existingComment.body !== messageBody) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: messageBody
                });
              }
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: number,
                body: messageBody
              });
            }
          }

          // Fetch all comments once
          const comments = await getAllComments();
          const botComment = comments.find(c => c.body.includes(header));
          const issueErrorComment = comments.find(c => c.body.includes("does not exist in this repository"));

          // Bypass Logic
          if (title.toUpperCase().includes("NOISSUE")) {
            core.info("Bypass keyword 'NOISSUE' detected.");
            await deleteCommentIfExists(botComment?.id);
            await deleteCommentIfExists(issueErrorComment?.id);
            core.info("Validation bypassed - no further checks performed.");
            return;
          }

          // Regex Validation
          const titleRegex = /^([a-z]+)\/(\d+)\/(.+)/i;
          const match = title.match(titleRegex);

          if (!match) {
            core.warning("Title does not match required format: type/issue-number/description");
            const errorMessage = `${header} Please use \`type/issue-number/description\` or include \`NOISSUE\` in the title.\n\nExample: \`feat/123/add-new-feature\``;
            await createOrUpdateComment(botComment, errorMessage);
            core.setFailed("PR title format is invalid");
            return; 
          }

          // Clean up format validation comment if title is now valid
          await deleteCommentIfExists(botComment?.id);
          core.info("Title format validation passed.");

          const issueNumber = match[2];

          // Validate issue number is numeric
          if (!/^\d+$/.test(issueNumber)) {
            core.setFailed(`Invalid issue number: ${issueNumber}. Must be numeric.`);
            return;
          }

          const closingKeyword = `Fixes #${issueNumber}`;

          // Validate issue exists in repository
          try {
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            core.info(`âœ“ Issue #${issueNumber} exists: "${issue.title}"`);
            
            // Issue exists - remove any previous error comment
            await deleteCommentIfExists(issueErrorComment?.id);
            
          } catch (error) {
            if (error.status === 404) {
              core.error(`Issue #${issueNumber} does not exist in this repository`);
              
              const errorMessage = `**Issue Validation Failed**\n\nIssue #${issueNumber} does not exist in this repository. Please create the issue first or update your PR title with the correct issue number.`;
              await createOrUpdateComment(issueErrorComment, errorMessage);
              
              core.setFailed(`Issue #${issueNumber} does not exist in this repository.`);
              return;
            }
            
            // Re-throw unexpected errors
            throw error;
          }

          // Add Issue Linking or update if needed
          let currentBody = body || "";

          // Check if we already have the correct Fixes line with the same issue number
          if (currentBody.includes(closingKeyword)) {
            core.info(`${closingKeyword} already exists in PR body - no update needed`);
          } else {
            core.info(`Updating PR body with ${closingKeyword}`);
            
            // Remove all existing "Fixes #" lines to avoid duplicates
            const fixesRegex = /Fixes #\d+/gi;
            currentBody = currentBody.replace(fixesRegex, '').trim();

            // Try to insert before the template comment
            const templateComment = "<!-- include a link to a GitHub issue, if applicable -->";
            if (currentBody.includes(templateComment)) {
              currentBody = currentBody.replace(
                templateComment,
                `${closingKeyword}\n${templateComment}`
              );
            } else {
              // Template comment not found - append to the beginning
              core.info("Template comment not found - prepending Fixes line to PR body");
              currentBody = `${closingKeyword}\n\n${currentBody}`;
            }
            
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: number,
              body: currentBody.trim()
            });
            
            core.info("PR body updated successfully");
          }