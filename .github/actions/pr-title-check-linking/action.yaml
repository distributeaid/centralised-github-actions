name: 'PR Title Linker & Labeler'
description: 'Enforces PR title conventions, links issues, and applies labels.'
inputs:
  github-token:
    description: 'GitHub Token for API access'
    required: true

runs:
  using: "composite"
  steps:
    - name: Run PR Metadata Script
      uses: actions/github-script@v8
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const { title, body, number } = context.payload.pull_request;
          const header = "⚠️ **Watch out! Invalid PR Title Format:**";
          const managedMarker = "";
          const managedTypes = ['feat', 'fix', 'chore', 'docs', 'refactor', 'bug', 'style', 'test'];

          // Fetch current context
          const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: number,
          });
          const currentLabelNames = currentLabels.map(l => l.name.toLowerCase());

          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: number,
          });
          const botComment = comments.find(c => c.body.includes(header));

          // Bypass Logic
          if (title.toUpperCase().includes("NOISSUE")) {
            core.info("Bypass keyword 'NOISSUE' detected.");
            if (botComment) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id
              });
              core.info("Deleted previous validation warning.");
            }
            return;
          }

          // Regex Validation
          const titleRegex = /^([a-z]+)\/(\d+)\/(.+)/i;
          const match = title.match(titleRegex);

          if (!match) {
            core.warning("Title does not match required format: type/issue-number/description");
            if (!botComment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: number,
                body: `${header} Please use \`type/issue-number/description\` or include \`NOISSUE\` in the title.`
              });
            }
            return; 
          }

          // Clean up bot comment if title is now valid
          if (botComment) {
            await github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id
            });
          }

          const prType = match[1].toLowerCase();
          const issueNumber = match[2];
          const closingKeyword = `Fixes #${issueNumber}`;

          // Validate issue exists in "DA Tech" organization project board
          try {
            const projectQuery = `
              query($org: String!) {
                organization(login: $org) {
                  projectsV2(first: 10, query: "DA Tech") {
                    nodes {
                      title
                      number
                      items(first: 100) {
                        totalCount
                        nodes {
                          content {
                            ... on Issue {
                              number
                              repository {
                                name
                                owner {
                                  login
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const result = await github.graphql(projectQuery, {
              org: context.repo.owner
            });

            // DEBUG: Log all projects found
            core.info(`Projects found: ${result.organization.projectsV2.nodes.map(p => p.title).join(', ')}`);

            const daTechProject = result.organization.projectsV2.nodes.find(p => p.title === "DA Tech");
            
            if (!daTechProject) {
              core.error("Available projects: " + result.organization.projectsV2.nodes.map(p => p.title).join(', '));
              throw new Error("DA Tech project not found");
            }

            // DEBUG: Log project stats
            core.info(`DA Tech project has ${daTechProject.items.totalCount} total items (fetched first 100)`);
            
            // DEBUG: Log first few issue numbers
            const issueNumbers = daTechProject.items.nodes
              .filter(item => item.content?.number)
              .map(item => `#${item.content.number} (${item.content.repository?.owner?.login}/${item.content.repository?.name})`);
            core.info(`Sample issues in board: ${issueNumbers.slice(0, 10).join(', ')}`);

            const issueExists = daTechProject.items.nodes.some(item => {
              const matches = item.content?.number === parseInt(issueNumber) && 
                            item.content?.repository?.name === context.repo.repo &&
                            item.content?.repository?.owner?.login === context.repo.owner;
              
              if (item.content?.number === parseInt(issueNumber)) {
                core.info(`Found issue #${issueNumber} but checking repo: ${item.content?.repository?.owner?.login}/${item.content?.repository?.name} vs ${context.repo.owner}/${context.repo.repo}`);
              }
              
              return matches;
            });

            if (!issueExists) {
              core.error(`Issue #${issueNumber} not found in first 100 items of DA Tech board for repo ${context.repo.owner}/${context.repo.repo}`);
              throw new Error("Issue not in DA Tech board");
            }
            
            core.info(`✓ Issue #${issueNumber} validated in DA Tech board`);
            
            // Issue exists - remove any previous error comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: number,
            });
            const issueErrorComment = comments.find(c => c.body.includes("❌ Issue #") && c.body.includes("does not exist"));
            
            if (issueErrorComment) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: issueErrorComment.id
              });
              core.info("Deleted previous issue validation error comment.");
            }
            
          } catch (error) {
            core.error(`Validation error: ${error.message}`);
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: number,
            });
            const issueErrorComment = comments.find(c => c.body.includes("❌ Issue #") && c.body.includes("does not exist"));
            
            if (issueErrorComment) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: issueErrorComment.id
              });
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: number,
              body: `❌ Issue #${issueNumber} does not exist in the "DA Tech" project board.`
            });
            
            core.setFailed(`Issue #${issueNumber} does not exist in the "DA Tech" project board.`);
            return;
          }

          // Add Issue Linking or updates if needed
          let currentBody = body || "";

          // Remove any existing "Fixes #" lines to prevent duplicates
          const fixesRegex = /Fixes #\d+/gi;
          currentBody = currentBody.replace(fixesRegex, '').trim();

          // Add the new closing keyword in the "What changed?" section
          if (currentBody.includes("## What changed?")) {
            // Insert after the "What changed?" header
            currentBody = currentBody.replace(
              /(## What changed?\n)/,
              `$1${closingKeyword}\n`
            );
          } else {
            // Fallback: append at the end
            currentBody = `${currentBody}\n\n${closingKeyword}`;
          }

          await github.rest.pulls.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: number,
            body: currentBody.trim()
          });

          // Label Management (only if within valid types)
          if (managedTypes.includes(prType) && !currentLabelNames.includes(prType)) {
            core.info(`Adding label: ${prType}`);
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: number,
              labels: [prType]
            }).catch(e => core.error(`Add label failed: ${e.message}`));
          }

          for (const label of currentLabelNames) {
            if (managedTypes.includes(label) && label !== prType) {
              core.info(`Removing outdated label: ${label}`);
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: number,
                name: label
              }).catch(() => {});
            }
          }