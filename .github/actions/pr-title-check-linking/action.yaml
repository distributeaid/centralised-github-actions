name: 'PR Title Linker & Labeler'
description: 'Enforces PR title conventions, links issues, and applies labels.'
inputs:
  github-token:
    description: 'GitHub Token for API access'
    required: true

runs:
  using: "composite"
  steps:
    - name: Run PR Metadata Script
      uses: actions/github-script@v8
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const { title, body, number } = context.payload.pull_request;
          const header = "⚠️ **Watch out! Invalid PR Title Format:**";
          const managedMarker = "";
          const managedTypes = ['feat', 'fix', 'chore', 'docs', 'refactor', 'bug', 'style', 'test'];

          // Fetch current context
          const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: number,
          });
          const currentLabelNames = currentLabels.map(l => l.name.toLowerCase());

          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: number,
          });
          const botComment = comments.find(c => c.body.includes(header));

          // Bypass Logic
          if (title.toUpperCase().includes("NOISSUE")) {
            core.info("Bypass keyword 'NOISSUE' detected.");
            if (botComment) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id
              });
              core.info("Deleted previous validation warning.");
            }
            return;
          }

          // Regex Validation
          const titleRegex = /^([a-z]+)\/(\d+)\/(.+)/i;
          const match = title.match(titleRegex);

          if (!match) {
            core.warning("Title does not match required format: type/issue-number/description");
            if (!botComment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: number,
                body: `${header} Please use \`type/issue-number/description\` or include \`NOISSUE\` in the title.`
              });
            }
            return; 
          }

          // Clean up bot comment if title is now valid
          if (botComment) {
            await github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id
            });
          }

          const prType = match[1].toLowerCase();
          const issueNumber = match[2];
          const closingKeyword = `Fixes #${issueNumber}`;

          // Updates the PR body to include the closing keyword if it's not already present
          let currentBody = body || "";
          
          if (!currentBody.includes(closingKeyword)) {
            core.info(`Updating PR body to link issue #${issueNumber}`);
            let newBody;

            if (currentBody.includes(managedMarker)) {
              // Replace ONLY the line after our marker
              const regex = new RegExp(`${managedMarker}[\\s\\S]*`, 'g');
              newBody = currentBody.replace(regex, `${managedMarker}\n${closingKeyword}`);
            } else {
              // Append to the end if marker doesn't exist
              newBody = `${currentBody}\n\n${managedMarker}\n${closingKeyword}`;
            }

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: number,
              body: newBody.trim()
            });
          }

          // Label Management (only if within valid types)
          if (managedTypes.includes(prType) && !currentLabelNames.includes(prType)) {
            core.info(`Adding label: ${prType}`);
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: number,
              labels: [prType]
            }).catch(e => core.error(`Add label failed: ${e.message}`));
          }

          for (const label of currentLabelNames) {
            if (managedTypes.includes(label) && label !== prType) {
              core.info(`Removing outdated label: ${label}`);
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: number,
                name: label
              }).catch(() => {});
            }
          }